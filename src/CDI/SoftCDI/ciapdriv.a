	nam ciapdriv
	use c:\DEFS\OSKDEFS.D
	use softcdi.d
	use softcdi.m

typelang	equ	(Drivr<<8)+Objct
attrrevs	equ	((ReEnt+SupStat)<<8)+$99 Not reentrant
edition		equ	0
stacksize	equ	0

	psect ciapdriv,typelang,attrrevs,edition,stacksize,EntryTable

EntryTable	dc.w	Init
		dc.w	Read
		dc.w	Write
		dc.w	GetStat
		dc.w	SetStat
		dc.w	Term
		dc.w	0		Trap handler
		dc.w	Play	CDFM specific (GB VII.3.1.5)

Init
* Register IRQ handler
	moveq #CdfmDriver_Vector,d0		Vector number
	moveq #CdfmDriver_Priority,d1		priority
	lea Irq(pc),a0		IRQ service routine entry point
*						device static storage is already in a2
	movea.l #CdfmDriver_Port,a3		port address
	os9 F$IRQ
	bcc.s Init_NoError
	moveq #0,d0
	os9 F$PErr

Init_NoError
	rts

* This call is synchronous, meaning it must F$Sleep until the data has been read.
Read
	softcdi $102
	rts

Write
	softcdi $103
	rts

GetStat
	softcdi Ucm_GetStat
	rts

SetStat
	softcdi Ucm_SetStat
	rts

Term
* Remove IRQ entry
	moveq #CdfmDriver_Vector,d0		Vector number
	movea.l #0,a0		delete IRQ service routine entry point
*						device static storage is already in a2
	os9 F$IRQ
	bcc.s Term_NoError
	moveq #0,d0
	os9 F$PErr

Term_NoError
	rts

* GB VII.3.1.5.7
* The PLAY subroutine sets up the controller's registers to 'play' a selection. The PLAY routine must:
* (1) Get the starting sector for the play from the path descriptor.
* (2) Seek to the starting sector if necessary.
* (3) Set up the file number selection mechanism using the file number from the path descriptor.
* (4) Set up the channel number selection mechanism using the channel mask from the Play Control Block.
* Note: The Play entry point will be called to read all Mode 2 sectors. The Read entry will be called to read Mode 1 sectors.
*
* Input: (a1) = Path descriptor pointer
* (a2) = Device static storage pointer
* (a4) = Process descriptor pointer
* (a6) = System global data storage pointer
* Output: None
* Error Output: cc = Carry bit set to one
* d1.w = Error code
*
* Play is asynchronous, meaning the data is being read after the system call has returned.
* However for some reads, it should sleep (like reading the Disc Label).
Play
	softcdi CdfmDriver_Play

	movea.l PD_PCB(a1),a3	Get FM's Play Control Block address
	move.w #$100,PCB_Stat(a3)	PCB_Stat, Play is finished

	movea.l PD_DTPtr(a1),a2		Get Drive table
	clr.w V_PLAY(a2)			Clear current play selection

	move.w P$ID(a4),d0
	move.w #S$Wake,d1
	os9 F$Send			Wake up file manager
	rts

* Service routines conform to the following register conventions:
* INPUT: (a2) = global static pointer
* 	(a3) = port address
* 	(a6) = system global data pointer (D_’s)
* 	(a7) = system stack (in active proc’s descriptor)
* OUTPUT: None
* ERROR OUTPUT: Carry bit set if the device did not cause the interrupt.
* WARNING: Interrupt service routines may destroy the following registers: d0,
* d1, a0, a2, a3, and/or a6. You must preserve all other registers used.
*
* The idea is after 1/75th of a second the virtual machine scheduler triggers an IRQ to my driver.
* The IRQ handler will send a signal to CDFM to tell it the sector has been read.
Irq
	rts

	vsect
	ds.w 0x50
	ends

	ends
